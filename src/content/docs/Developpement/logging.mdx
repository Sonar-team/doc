---
title: Comment afficher les paquets r√©seau en temps r√©el dans une application Tauri
description: Un guide de terrain, √©tape par √©tape, pour comprendre la construction d'une fonction de logging des paquets dans une application Tauri.
sidebar:
  order: 405
---

# üõ∞Ô∏è Journalisation des paquets r√©seau dans l'application SONAR

## üìå Objectif

L‚Äôobjectif du logging des paquets dans SONAR est de fournir une **trace en temps r√©el** des trames captur√©es sur les interfaces r√©seau. Cela permet :

- üïµÔ∏è‚Äç‚ôÇÔ∏è D‚Äôinspecter les paquets au fur et √† mesure de leur r√©ception.
- üìä D‚Äôobserver les caract√©ristiques des flux r√©seau (protocole, IP, ports...).
- ‚è±Ô∏è De diagnostiquer rapidement des anomalies de trafic ou de configuration.
- üß† D‚Äôalimenter une interface utilisateur r√©active pour l‚Äôanalyse en direct.

---

## üß± Architecture de la journalisation

La capture et l‚Äôaffichage en temps r√©el dans SONAR repose sur une architecture en **thread parall√®le** avec communication via **canal Crossbeam** :

```mermaid
flowchart TD
    ThreadCap[Thread Cap] --> ThreadProc[Thread Proc]
    ThreadProc --> emit[emit frame]
    emit --> InterfaceUser[Interface utilisateur]
```

* `Thread Cap` : capture les paquets en brut via `pcap`.
* `Thread Proc` : transforme chaque paquet en structure `PacketFlow`, puis les envoie √† l'UI via `emit`.
* Frontend Vue.js : √©coute les √©v√©nements `frame` et affiche les derniers paquets re√ßus.

---

## üì¶ Structure du paquet journalis√©

Chaque paquet est encapsul√© dans une structure Rust typ√©e :

```rust
#[derive(Debug, Clone, Serialize)]
pub struct PacketFlow {
    pub ts_sec: i64,
    pub ts_usec: i64,
    pub caplen: u32,
    pub len: u32,
    pub flow: PacketInfos,
    pub formatted_time: String, // Ex: "14:35:09.366315"
}
```

Le champ `flow` contient les informations multi-couches :

```rust
pub struct PacketInfos {
    pub mac_address_source: String,
    pub mac_address_destination: String,
    pub interface: String,
    pub l_3_protocol: String,
    pub layer_3_infos: Option<Layer3Infos>,
    pub packet_size: u32,
}
```

---

## ‚è≤Ô∏è Formatage de l‚Äôhorodatage

Pour faciliter la lecture humaine et l‚Äôalignement temporel, un champ `formatted_time` est inject√© dans le backend lors de la cr√©ation de chaque paquet :

```rust
fn format_timestamp(ts_sec: i64, ts_usec: i64) -> String {
    use chrono::{NaiveDateTime, Timelike};
    let naive = NaiveDateTime::from_timestamp_opt(ts_sec, (ts_usec * 1000) as u32)
        .unwrap_or_else(|| NaiveDateTime::from_timestamp_opt(0, 0).unwrap());
    let micro = ts_usec % 1_000_000;

    format!(
        "{:02}:{:02}:{:02}.{:06}",
        naive.hour(),
        naive.minute(),
        naive.second(),
        micro
    )
}
```

---

## üßë‚Äçüíª Affichage dans l‚Äôinterface

La table Vue.js est li√©e √† un tableau `frames` :

```vue
<tr v-for="(frame, index) in frames" :key="index">
  <td>{{ frame.flow.mac_address_source }}</td>
  <td>{{ frame.flow.mac_address_destination }}</td>
  <td>{{ frame.flow.interface }}</td>
  <td>{{ frame.flow.l_3_protocol }}</td>
  <td>{{ frame.flow.layer_3_infos?.ip_source || '-' }}</td>
  <td>{{ frame.flow.layer_3_infos?.ip_destination || '-' }}</td>
  <td>{{ frame.flow.layer_3_infos?.l_4_protocol || '-' }}</td>
  <td>{{ frame.flow.layer_3_infos?.layer_4_infos?.port_source || '-' }}</td>
  <td>{{ frame.flow.layer_3_infos?.layer_4_infos?.port_destination || '-' }}</td>
  <td>{{ frame.flow.layer_3_infos?.layer_4_infos?.l_7_protocol || '-' }}</td>
  <td>{{ frame.flow.packet_size }}</td>
  <td>{{ frame.formatted_time }}</td>
</tr>
```

---

## üõë Limitation volontaire : uniquement les 5 derniers paquets

Afin de ne pas saturer l'interface, le backend conserve une **file circulaire de 5 paquets** :

```rust
if last_packets.len() == 5 {
    last_packets.pop_back();
}
last_packets.push_front(packet_info);
```

---

## üîÑ R√©initialisation

Un √©v√©nement `reset` est √©cout√© c√¥t√© frontend pour vider la table :

```js
this.$bus.on('reset', () => {
  this.frames = [];
});
```

---

## ‚úÖ Conclusion

Le logging r√©seau en temps r√©el dans SONAR est une brique essentielle pour :

* L‚Äôanalyse instantan√©e du trafic
* Le d√©bogage
* Le contr√¥le de performance des captures

Cette architecture bas√©e sur Tauri, Crossbeam et Vue.js offre √† la fois performance, clart√© et r√©activit√©.

---

üõ†Ô∏è Besoin de plus ?
SONAR peut √©voluer pour afficher :

* Une timeline horizontale en temps r√©el

